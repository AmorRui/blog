/*
Navicat MySQL Data Transfer

Source Server         : 127.0.0.1
Source Server Version : 50637
Source Host           : localhost:3306
Source Database       : blog

Target Server Type    : MYSQL
Target Server Version : 50637
File Encoding         : 65001

Date: 2018-02-17 16:05:20
*/

SET FOREIGN_KEY_CHECKS=0;

-- ----------------------------
-- Table structure for `article`
-- ----------------------------
DROP TABLE IF EXISTS `article`;
CREATE TABLE `article` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `title` varchar(255) NOT NULL,
  `jianjie` varchar(255) NOT NULL,
  `content` text NOT NULL,
  `img` char(255) DEFAULT NULL,
  `year` int(255) NOT NULL,
  `mounth` int(255) NOT NULL,
  `day` int(255) NOT NULL,
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=152 DEFAULT CHARSET=utf8;

-- ----------------------------
-- Records of article
-- ----------------------------
INSERT INTO `article` VALUES ('124', '正则表达式总结笔记', 'live like youself.简单分类简单类原则上正则的一个字符对应一个字符如：如/ruby/，匹配ruby字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符如/[ruby]/ ,只匹配其中一个字符负向类前面加个元字符进行取反，表示匹配不能为括号里面的字符范围类如/[a-f]/,/[1-2]/组合类允许用中括号匹配不同类型的单个字符。...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h1 id=\"&#x7B80;&#x5355;&#x5206;&#x7C7B;\">&#x7B80;&#x5355;&#x5206;&#x7C7B;</h1>\n\n<hr>\n\n<h2 id=\"&#x7B80;&#x5355;&#x7C7B;\">&#x7B80;&#x5355;&#x7C7B;</h2>\n<p>&#x539F;&#x5219;&#x4E0A;&#x6B63;&#x5219', '/uploads\\avater.jpg', '2018', '2', '11');
INSERT INTO `article` VALUES ('127', 'esLint 使用总结（1）', 'live like youself.配置 ESLint:可以通过以下三种方式配置 ESLint:1.使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）；2.在 package.json 中添加 eslintConfig 配置块；3.直接在代码文件中定义。这里选用第一种以json的形式来编写使用eslint之前，我们要配置编译器的插件，让编...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x914D;&#x7F6E;-eslint\">&#x914D;&#x7F6E; ESLint:</h2>\n\n<p>&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4EE5;&#x4E0B;&#x4E09;&#x79CD;&#x65B9;&#x5F0F;&#x914D;&#x7F6E; ESLint:</p>\n\n<p>1.&#x4F7F;&#x', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('128', '对connect使用总结', 'live like youself.在react+redux项目中有一个至关重要的API，它就是：connect(mapStateProps, mapDispatchToProps, mergeProps, options)今天让我们来看一下我们如何使用此API，建议有一定的react+redux开发经验，但不是很明白connect的使用原理的开发者观看此文章mapStat...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<p>&#x5728;react+redux&#x9879;&#x76EE;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x81F3;&#x5173;&#x91CD;&#x8981;&#x7684;API&#xFF0C;&#x5B83;&#x5C31;&#x662F;&#xFF1A;connect(mapStateProps, mapDispatchToProp', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('129', 'esLint 使用总结（2）', 'live like youself.开始自定义配置默认情况下，ESLint 支持 ECMAScript 5 语法那当我们想使用 ECMAScript 6 ，甚至更新的语法，而不至于编译器飘红，我们该怎么办呢？ESLint 允许你指定你想要支持的 JavaScript 语言选项在.eslintrc 文件使用 parserOptions 属性设置解析器选项.eslintr...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x5F00;&#x59CB;&#x81EA;&#x5B9A;&#x4E49;&#x914D;&#x7F6E;\">&#x5F00;&#x59CB;&#x81EA;&#x5B9A;&#x4E49;&#x914D;&#x7F6E;</h2>\n\n<p>&#x9ED8;&#x8BA4;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;ESLint &#x652', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('130', 'react生命周期', 'live like youself.前言react项目中生命周期是一个较为重要的概念，今天我们便来总结一下，生命周期的故事在react组件的开发过程中，我们有时会利用组件的不同状态，对组件进行操作，打个比方，类似人的一生，react组件从开始挂载到卸载也分为不同的周期，类比人的出生前，出生时，出生后，幼年，青年，老年的过程。先让我们用一张图片，来观察一下一个组件的一生吧...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x524D;&#x8A00;\">&#x524D;&#x8A00;</h2>\n前言\r\nreact项目中生命周期是一个较为重要的概念，今天我们便来总结一下，生命周期的故事\r\n\r\n在react组件的开发过程中，我们有时会利用组件的不同状态，对组件进行操作，打个比方，类似人的一生，react组件从开始挂载到卸载也分为不同的周期，类比人的出生前，出生时，出生后，幼年，青年，', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('131', 'let 和 const以及块级作用域', 'live like youself.let基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。例如：{    let a = 10;    var b = 1;}a // ReferenceError: a is not defined.b // 1在代码块之外调用这两个变量，...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"let\">let</h2>\n\n<h4 id=\"&#x57FA;&#x672C;&#x7528;&#x6CD5;\">&#x57FA;&#x672C;&#x7528;&#x6CD5;</h4>\n\n<p>ES6 &#x65B0;&#x589E;&#x4E86;let&#x547D;&#x4EE4;&#xFF0C;&#x7528;&#x6765;&#x58F0;&#x660E', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('132', 'git 基础使用总结（2）----分支与变基', 'live like youself.分支为什么要使用分支开发某个网站。举个例子：1.为实现某个新的需求，创建一个分支。2.在这个分支上开展工作。3.正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：4.切换到你的线上分支（production branch）。5.为这个紧急任务新建一个分支，并在其中修复它。6.在测试通过之...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h1 id=\"&#x5206;&#x652F;\">&#x5206;&#x652F;</h1>\n\n<p>&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4F7F;&#x7528;&#x5206;&#x652F;&#x5F00;&#x53D1;&#x67D0;&#x4E2A;&#x7F51;&#x7AD9;&#x3002;</p>\n\n<p>&#x4E3E;&#x4', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('133', 'git 基础使用总结（1）--基础应用', 'live like youself.写在前面git和github并不能混为一谈1.git 可以在 .git 文件夹里面维护你的历史代码2.github是用Git做版本控制的代码托管平台，每家公司或者包括你自己都可以有一个自己的代码托管平台3.使用代码托管平台时，需要上传本地的公钥具体教程使用git前应输入此命令配置git config --global ...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h1 id=\"&#x5199;&#x5728;&#x524D;&#x9762;\">&#x5199;&#x5728;&#x524D;&#x9762;</h1>\n\n<p>git&#x548C;github&#x5E76;&#x4E0D;&#x80FD;&#x6DF7;&#x4E3A;&#x4E00;&#x8C08;</p>\n\n<p>1.git &#x53EF;&#x4EE5;&#x57', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('134', 'string.prototype常用方法中slice substr substring', 'live like youself.str.substr(start[, length])提取字符串的一部分，不改变原字符串参数1.start :开始提取字符串的位置，若为负数，则重字符串末尾开始，str.substr(str.length-1) 等价于str.substr(-1);2.Length :可选参数，截取字符串的长度，如不填则默认截取到字符串末尾注...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"strsubstrstart-length\">str.substr(start[, length])</h2>\n\n<p>&#x63D0;&#x53D6;&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF0C;&#x4E0D;&#x6539;&#x53D8;&#x539F;&#x5B57;&#x7B', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('135', 'SASS入门学习总结', 'live like youself.SASS是一种css开发工具，SASS使用Ruby语言写的基本用法变量SASS允许使用变量，所有变量用$开头例如：　　$blue : #1875e7;　　　div {　　　color : $blue;　　}如果变量需要镶嵌到字符串之中，就必须写在#{}之中。例如　　$side : left;...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<p>SASS&#x662F;&#x4E00;&#x79CD;css&#x5F00;&#x53D1;&#x5DE5;&#x5177;&#xFF0C;SASS&#x4F7F;&#x7528;Ruby&#x8BED;&#x8A00;&#x5199;&#x7684;</p>\n\n<hr>\n\n<h1 id=\"&#x57FA;&#x672C;&#x7528;&#x6CD5;\">&#x57FA;&', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('136', '正则表达式总结笔记', 'live like youself.简单分类简单类原则上正则的一个字符对应一个字符如：如/ruby/，匹配ruby字符，我们可以用[]把它们括起来，让[]这个整体对应一个字符如/[ruby]/ ,只匹配其中一个字符负向类前面加个元字符进行取反，表示匹配不能为括号里面的字符范围类如/[a-f]/,/[1-2]/组合类允许用中括号匹配不同类型的单个字符。...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h1 id=\"&#x7B80;&#x5355;&#x5206;&#x7C7B;\">&#x7B80;&#x5355;&#x5206;&#x7C7B;</h1>\n\n<hr>\n\n<h2 id=\"&#x7B80;&#x5355;&#x7C7B;\">&#x7B80;&#x5355;&#x7C7B;</h2>\n<p>&#x539F;&#x5219;&#x4E0A;&#x6B63;&#x5219', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('137', '基于React,Redux中mvc的理解', 'live like youself.首先解释一下什么是MVC。  model持有UI要展现的数据  View即UI的展现  Controller用于控制在react+redux项目中的mvc1.React扮演的是View的角色2.Redux则是Controller3.至于Model就是Redux Store中存储的State。这就是我所理解的rea...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x9996;&#x5148;&#x89E3;&#x91CA;&#x4E00;&#x4E0B;&#x4EC0;&#x4E48;&#x662F;mvc\">&#x9996;&#x5148;&#x89E3;&#x91CA;&#x4E00;&#x4E0B;&#x4EC0;&#x4E48;&#x662F;MVC&#x3002;</h2>\n\n<ul>\n  <li>model&#', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('138', 'esLint 使用总结（2）', 'live like youself.开始自定义配置默认情况下，ESLint 支持 ECMAScript 5 语法那当我们想使用 ECMAScript 6 ，甚至更新的语法，而不至于编译器飘红，我们该怎么办呢？ESLint 允许你指定你想要支持的 JavaScript 语言选项在.eslintrc 文件使用 parserOptions 属性设置解析器选项.eslintr...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x5F00;&#x59CB;&#x81EA;&#x5B9A;&#x4E49;&#x914D;&#x7F6E;\">&#x5F00;&#x59CB;&#x81EA;&#x5B9A;&#x4E49;&#x914D;&#x7F6E;</h2>\n\n<p>&#x9ED8;&#x8BA4;&#x60C5;&#x51B5;&#x4E0B;&#xFF0C;ESLint &#x652', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('139', 'esLint 使用总结（1）', 'live like youself.配置 ESLint:可以通过以下三种方式配置 ESLint:1.使用 .eslintrc 文件（支持 JSON 和 YAML 两种语法）；2.在 package.json 中添加 eslintConfig 配置块；3.直接在代码文件中定义。这里选用第一种以json的形式来编写使用eslint之前，我们要配置编译器的插件，让编...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x914D;&#x7F6E;-eslint\">&#x914D;&#x7F6E; ESLint:</h2>\n\n<p>&#x53EF;&#x4EE5;&#x901A;&#x8FC7;&#x4EE5;&#x4E0B;&#x4E09;&#x79CD;&#x65B9;&#x5F0F;&#x914D;&#x7F6E; ESLint:</p>\n\n<p>1.&#x4F7F;&#x', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('140', '对connect使用总结', 'live like youself.在react+redux项目中有一个至关重要的API，它就是：connect(mapStateProps, mapDispatchToProps, mergeProps, options)今天让我们来看一下我们如何使用此API，建议有一定的react+redux开发经验，但不是很明白connect的使用原理的开发者观看此文章mapStat...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<p>&#x5728;react+redux&#x9879;&#x76EE;&#x4E2D;&#x6709;&#x4E00;&#x4E2A;&#x81F3;&#x5173;&#x91CD;&#x8981;&#x7684;API&#xFF0C;&#x5B83;&#x5C31;&#x662F;&#xFF1A;connect(mapStateProps, mapDispatchToProp', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('141', 'Hello World', 'live like youself.前言于华健 的 Blog 就这么开通了 fork了Hux前辈的博客样式，我终于动笔写下了自己的第一篇博客,@Hux,在此致谢。不想看矫情的话？点这里 准备很长时间，磕磕绊绊的总算是把博客开通了，在此非常感谢各位走在前方的前辈，为我们这些后来者，留下了如此多宝贵的教程和经验前端技术可以说是我大学生活的救赎，懵懂肆意玩耍了两年，迷茫...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x524D;&#x8A00;\">&#x524D;&#x8A00;</h2>\n\n<p>&#x4E8E;&#x534E;&#x5065; &#x7684; Blog &#x5C31;&#x8FD9;&#x4E48;&#x5F00;&#x901A;&#x4E86; fork&#x4E86;Hux&#x524D;&#x8F88;&#x7684;&#x535A;&#x5BA', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('142', 'react生命周期', 'live like youself.前言react项目中生命周期是一个较为重要的概念，今天我们便来总结一下，生命周期的故事在react组件的开发过程中，我们有时会利用组件的不同状态，对组件进行操作，打个比方，类似人的一生，react组件从开始挂载到卸载也分为不同的周期，类比人的出生前，出生时，出生后，幼年，青年，老年的过程。先让我们用一张图片，来观察一下一个组件的一生吧...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"&#x524D;&#x8A00;\">&#x524D;&#x8A00;</h2>\n<p>react&#x9879;&#x76EE;&#x4E2D;&#x751F;&#x547D;&#x5468;&#x671F;&#x662F;&#x4E00;&#x4E2A;&#x8F83;&#x4E3A;&#x91CD;&#x8981;&#x7684;&#x6982;&#x5FF5;&', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('143', 'let 和 const以及块级作用域', 'live like youself.let基本用法ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。例如：{    let a = 10;    var b = 1;}a // ReferenceError: a is not defined.b // 1在代码块之外调用这两个变量，...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"let\">let</h2>\n\n<h4 id=\"&#x57FA;&#x672C;&#x7528;&#x6CD5;\">&#x57FA;&#x672C;&#x7528;&#x6CD5;</h4>\n\n<p>ES6 &#x65B0;&#x589E;&#x4E86;let&#x547D;&#x4EE4;&#xFF0C;&#x7528;&#x6765;&#x58F0;&#x660E', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('144', 'git 基础使用总结（2）----分支与变基', 'live like youself.分支为什么要使用分支开发某个网站。举个例子：1.为实现某个新的需求，创建一个分支。2.在这个分支上开展工作。3.正在此时，你突然接到一个电话说有个很严重的问题需要紧急修补。 你将按照如下方式来处理：4.切换到你的线上分支（production branch）。5.为这个紧急任务新建一个分支，并在其中修复它。6.在测试通过之...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h1 id=\"&#x5206;&#x652F;\">&#x5206;&#x652F;</h1>\n\n<p>&#x4E3A;&#x4EC0;&#x4E48;&#x8981;&#x4F7F;&#x7528;&#x5206;&#x652F;&#x5F00;&#x53D1;&#x67D0;&#x4E2A;&#x7F51;&#x7AD9;&#x3002;</p>\n\n<p>&#x4E3E;&#x4', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('145', 'git 基础使用总结（1）--基础应用', 'live like youself.写在前面git和github并不能混为一谈1.git 可以在 .git 文件夹里面维护你的历史代码2.github是用Git做版本控制的代码托管平台，每家公司或者包括你自己都可以有一个自己的代码托管平台3.使用代码托管平台时，需要上传本地的公钥具体教程使用git前应输入此命令配置git config --global ...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h1 id=\"&#x5199;&#x5728;&#x524D;&#x9762;\">&#x5199;&#x5728;&#x524D;&#x9762;</h1>\n\n<p>git&#x548C;github&#x5E76;&#x4E0D;&#x80FD;&#x6DF7;&#x4E3A;&#x4E00;&#x8C08;</p>\n\n<p>1.git &#x53EF;&#x4EE5;&#x57', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('146', 'string.prototype常用方法中slice substr substring', 'live like youself.str.substr(start[, length])提取字符串的一部分，不改变原字符串参数1.start :开始提取字符串的位置，若为负数，则重字符串末尾开始，str.substr(str.length-1) 等价于str.substr(-1);2.Length :可选参数，截取字符串的长度，如不填则默认截取到字符串末尾注...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<h2 id=\"strsubstrstart-length\">str.substr(start[, length])</h2>\n\n<p>&#x63D0;&#x53D6;&#x5B57;&#x7B26;&#x4E32;&#x7684;&#x4E00;&#x90E8;&#x5206;&#xFF0C;&#x4E0D;&#x6539;&#x53D8;&#x539F;&#x5B57;&#x7B', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('147', 'SASS入门学习总结', 'live like youself.SASS是一种css开发工具，SASS使用Ruby语言写的基本用法变量SASS允许使用变量，所有变量用$开头例如：　　$blue : #1875e7;　　　div {　　　color : $blue;　　}如果变量需要镶嵌到字符串之中，就必须写在#{}之中。例如　　$side : left;...', '\n\n				<blockquote>\n  <p>live like youself.</p>\n</blockquote>\n\n<p>SASS&#x662F;&#x4E00;&#x79CD;css&#x5F00;&#x53D1;&#x5DE5;&#x5177;&#xFF0C;SASS&#x4F7F;&#x7528;Ruby&#x8BED;&#x8A00;&#x5199;&#x7684;</p>\n\n<hr>\n\n<h1 id=\"&#x57FA;&#x672C;&#x7528;&#x6CD5;\">&#x57FA;&', '/uploads\\avater.jpg', '2018', '2', '12');
INSERT INTO `article` VALUES ('149', 'cookie和session有什么区别，请你谈谈cookie的缺点', 'cookie和session', '<p>1.区别:</p>\n\n<p>　　　　cookie机制采用的是在客户端保持状态的方案</p>\n\n<p>　　　　session机制采用的是在服务端保持状态的方案</p>\n\n<p>2.cookie:</p>\n\n<p>　　优点:</p>\n\n<p>　　　　1&gt; 极高的扩展性和可用性</p>\n\n<p>　　　　2&gt; 通过编程方式,控制保存在cookie中的session对象的大小</p>\n\n<p>　　　　3&gt;通过加密和SSL(安全传输技术),减少cookie被破解的可能性</p>\n\n<p>　　　', '/uploads\\avatar-1518790363957.jpg', '2018', '2', '16');
INSERT INTO `article` VALUES ('150', '1111111111111111111111111111111111', '这几年，前端技术发展很快，每年都有新的技术名词流行，ReactJS、Angular 2、VUE、微信小程序。。。而我重新学习了 swift ，是的，重新学习，之前读过《swift 1.0 从入门到放弃》  想起当年学习前端开发的经历，我开始写一些实际的小 app 来练手，总算是没有又一次『从入门到放弃』  有一天突然想到，每一天不管开心还是难过，不管是平淡还是难忘，都要过的有意义——从来不写日记的我第一次想每天花几分钟记录一下自己的一天了。（日记？上个世纪的东西了吧？！）  于是就尝试了各种 app，记事', '<p>这几年，前端技术发展很快，每年都有新的技术名词流行，ReactJS、Angular 2、VUE、微信小程序。。。而我重新学习了 swift ，是的，重新学习，之前读过《swift 1.0 从入门到放弃》</p>\n\n<p>想起当年学习前端开发的经历，我开始写一些实际的小 app 来练手，总算是没有又一次『从入门到放弃』</p>\n\n<p>有一天突然想到，每一天不管开心还是难过，不管是平淡还是难忘，都要过的有意义&mdash;&mdash;从来不写日记的我第一次想每天花几分钟记录一下自己的一天了。（日记？上个世纪的东西了吧？！）</p>\n\n<p>于是就尝试了各种 app，记事类的、日记类的。却发现每个 app 都想做的很完美，带上各种功能，需要的不需要的全都有，干扰的东西太多。。。</p>\n\n<p>我只想一个单纯的记录自己每一天的 app，几张图片，一段文字，最多再加上一个地理位置，嗯，真实的自己，只有自己能看到，也不用担心有没有人点赞。</p>\n\n<p>干脆就自己用 swift 写一个吧：One Day.</p>\n\n<p>有一天正在听最喜欢的《One Day》，嗯，海贼王中艾斯被行刑的那一段的主题曲，这段剧情也是海贼王中给我感受最深的一段。于是 App 的名字就叫 One Day 了。</p>\n\n<p>One Day 的目标就只有一个：记录『最真实的自己』。所以从一开始就完全抛弃了社交和分享的功能。</p>\n', '/uploads\\avatar-1518854621394.jpg', '2018', '2', '17');
INSERT INTO `article` VALUES ('151', '123', '123', '<p>2013年发布至今，&nbsp;Docker&nbsp;一直广受瞩目，被认为可能会改变软件行业。</p>\n\n<p>但是，许多人并不清楚 Docker 到底是什么，要解决什么问题，好处又在哪里？本文就来详细解释，帮助大家理解它，还带有简单易懂的实例，教你如何将它用于日常开发。</p>\n\n<p>&nbsp;</p>\n\n<h2>一、环境配置的难题</h2>\n\n<p>软件开发最大的麻烦事之一，就是环境配置。用户计算机的环境都不相同，你怎么知道自家的软件，能在那些机器跑起来？</p>\n\n<p>用户必须保证两件事：操作系统的设置，各种库和组件的安装。只有它们都正确，软件才能运行。举例来说，安装一个 Python 应用，计算机必须有 Python 引擎，还必须有各种依赖，可能还要配置环境变量。</p>\n\n<p>如果某些老旧的模块与当前环境不兼容，那就麻烦了。开发者常常会说：&quot;它在我的机器可以跑了&quot;（It works on my machine），言下之意就是，其他机器很可能跑不了。</p>\n\n<p>环境配置如此麻烦，换一台机器，就要重来一次，旷日费时。很多人想到，能不能从根本上解决问题，软件可以带环境安装？也就是说，安装的时候，把原始环境一模一样地复制过来。</p>\n\n<h2>二、虚拟机</h2>\n\n<p>虚拟机（virtual machine）就是带环境安装的一种解决方案。它可以在一种操作系统里面运行另一种操作系统，比如在 Windows 系统里面运行 Linux 系统。应用程序对此毫无感知，因为虚拟机看上去跟真实系统一模一样，而对于底层系统来说，虚拟机就是一个普通文件，不需要了就删掉，对其他部分毫无影响。</p>\n\n<p>虽然用户可以通过虚拟机还原软件的原始环境。但是，这个方案有几个缺点。</p>\n\n<p><strong>（1）资源占用多</strong></p>\n\n<p>虚拟机会独占一部分内存和硬盘空间。它运行的时候，其他程序就不能使用这些资源了。哪怕虚拟机里面的应用程序，真正使用的内存只有 1MB，虚拟机依然需要几百 MB 的内存才能运行。</p>\n\n<p><strong>（2）冗余步骤多</strong></p>\n\n<p>虚拟机是完整的操作系统，一些系统级别的操作步骤，往往无法跳过，比如用户登录。</p>\n\n<p><strong>（3）启动慢</strong></p>\n\n<p>启动操作系统需要多久，启动虚拟机就需要多久。可能要等几分钟，应用程序才能真正运行。</p>\n\n<h2>三、Linux 容器</h2>\n\n<p>由于虚拟机存在这些缺点，Linux 发展出了另一种虚拟化技术：Linux 容器（Linux Containers，缩写为 LXC）。</p>\n\n<p><strong>Linux 容器不是模拟一个完整的操作系统，而是对进程进行隔离。</strong>或者说，在正常进程的外面套了一个保护层。对于容器里面的进程来说，它接触到的各种资源都是虚拟的，从而实现与底层系统的隔离。</p>\n\n<p>由于容器是进程级别的，相比虚拟机有很多优势。</p>\n\n<p><strong>（1）启动快</strong></p>\n\n<p>容器里面的应用，直接就是底层系统的一个进程，而不是虚拟机内部的进程。所以，启动容器相当于启动本机的一个进程，而不是启动一个操作系统，速度就快很多。</p>\n\n<p><strong>（2）资源占用少</strong></p>\n\n<p>容器只占用需要的资源，不占用那些没有用到的资源；虚拟机由于是完整的操作系统，不可避免要占用所有资源。另外，多个容器可以共享资源，虚拟机都是独享资源。</p>\n\n<p><strong>（3）体积小</strong></p>\n\n<p>容器只要包含用到的组件即可，而虚拟机是整个操作系统的打包，所以容器文件比虚拟机文件要小很多。</p>\n\n<p>总之，容器有点像轻量级的虚拟机，能够提供虚拟化的环境，但是成本开销小得多。</p>\n\n<h2>四、Docker 是什么？</h2>\n\n<p><strong>Docker 属于 Linux 容器的一种封装，提供简单易用的容器使用接口。</strong>它是目前最流行的 Linux 容器解决方案。</p>\n\n<p>Docker 将应用程序与该程序的依赖，打包在一个文件里面。运行这个文件，就会生成一个虚拟容器。程序在这个虚拟容器里运行，就好像在真实的物理机上运行一样。有了 Docker，就不用担心环境问题。</p>\n\n<p>总体来说，Docker 的接口相当简单，用户可以方便地创建和使用容器，把自己的应用放入容器。容器还可以进行版本管理、复制、分享、修改，就像管理普通的代码一样。</p>\n\n<h2>五、Docker 的用途</h2>\n\n<p>Docker 的主要用途，目前有三大类。</p>\n\n<p><strong>（1）提供一次性的环境。</strong>比如，本地测试他人的软件、持续集成的时候提供单元测试和构建的环境。</p>\n\n<p><strong>（2）提供弹性的云服务。</strong>因为 Docker 容器可以随开随关，很适合动态扩容和缩容。</p>\n\n<p><strong>（3）组建微服务架构。</strong>通过多个容器，一台机器可以跑多个服务，因此在本机就可以模拟出微服务架构。</p>\n\n<h2>六、Docker 的安装</h2>\n\n<p>Docker 是一个开源的商业产品，有两个版本：社区版（Community Edition，缩写为 CE）和企业版（Enterprise Edition，缩写为 EE）。企业版包含了一些收费服务，个人开发者一般用不到。下面的介绍都针对社区版。</p>\n\n<p>Docker CE 的安装请参考官方文档。</p>\n\n<blockquote>\n<ul>\n	<li>Mac</li>\n	<li>Windows</li>\n	<li>Ubuntu</li>\n	<li>Debian</li>\n	<li>CentOS</li>\n	<li>Fedora</li>\n	<li>其他 Linux 发行版</li>\n</ul>\n</blockquote>\n\n<p>安装完成后，运行下面的命令，验证是否安装成功。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker version\n# 或者\n$ docker info\n</code></pre>\n</blockquote>\n\n<p>Docker 需要用户具有 sudo 权限，为了避免每次命令都输入<code>sudo</code>，可以把用户加入 Docker 用户组（官方文档）。</p>\n\n<blockquote>\n<pre>\n<code>\n$ sudo usermod -aG docker $USER\n</code></pre>\n</blockquote>\n\n<p>Docker 是服务器----客户端架构。命令行运行<code>docker</code>命令的时候，需要本机有 Docker 服务。如果这项服务没有启动，可以用下面的命令启动（官方文档）。</p>\n\n<blockquote>\n<pre>\n<code>\n# service 命令的用法\n$ sudo service docker start\n\n# systemctl 命令的用法\n$ sudo systemctl start docker\n</code></pre>\n</blockquote>\n\n<h2>六、image 文件</h2>\n\n<p><strong>Docker 把应用程序及其依赖，打包在 image 文件里面。</strong>只有通过这个文件，才能生成 Docker 容器。image 文件可以看作是容器的模板。Docker 根据 image 文件生成容器的实例。同一个 image 文件，可以生成多个同时运行的容器实例。</p>\n\n<p>image 是二进制文件。实际开发中，一个 image 文件往往通过继承另一个 image 文件，加上一些个性化设置而生成。举例来说，你可以在 Ubuntu 的 image 基础上，往里面加入 Apache 服务器，形成你的 image。</p>\n\n<blockquote>\n<pre>\n<code>\n# 列出本机的所有 image 文件。\n$ docker image ls\n\n# 删除 image 文件\n$ docker image rm [imageName]\n</code></pre>\n</blockquote>\n\n<p>image 文件是通用的，一台机器的 image 文件拷贝到另一台机器，照样可以使用。一般来说，为了节省时间，我们应该尽量使用别人制作好的 image 文件，而不是自己制作。即使要定制，也应该基于别人的 image 文件进行加工，而不是从零开始制作。</p>\n\n<p>为了方便共享，image 文件制作完成后，可以上传到网上的仓库。Docker 的官方仓库&nbsp;Docker Hub&nbsp;是最重要、最常用的 image 仓库。此外，出售自己制作的 image 文件也是可以的。</p>\n\n<h2>七、实例：hello world</h2>\n\n<p>下面，我们通过最简单的 image 文件&quot;hello world&quot;，感受一下 Docker。</p>\n\n<p>需要说明的是，国内连接 Docker 的官方仓库很慢，还会断线，需要将默认仓库改成国内的镜像网站，具体的修改方法在下一篇文章的第一节。有需要的朋友，可以先看一下。</p>\n\n<p>首先，运行下面的命令，将 image 文件从仓库抓取到本地。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image pull library/hello-world\n</code></pre>\n</blockquote>\n\n<p>上面代码中，<code>docker image pull</code>是抓取 image 文件的命令。<code>library/hello-world</code>是 image 文件在仓库里面的位置，其中<code>library</code>是 image 文件所在的组，<code>hello-world</code>是 image 文件的名字。</p>\n\n<p>由于 Docker 官方提供的 image 文件，都放在<code>library</code>组里面，所以它的是默认组，可以省略。因此，上面的命令可以写成下面这样。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image pull hello-world\n</code></pre>\n</blockquote>\n\n<p>抓取成功以后，就可以在本机看到这个 image 文件了。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image ls\n</code></pre>\n</blockquote>\n\n<p>现在，运行这个 image 文件。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container run hello-world\n</code></pre>\n</blockquote>\n\n<p><code>docker container run</code>命令会从 image 文件，生成一个正在运行的容器实例。</p>\n\n<p>注意，<code>docker container run</code>命令具有自动抓取 image 文件的功能。如果发现本地没有指定的 image 文件，就会从仓库自动抓取。因此，前面的<code>docker image pull</code>命令并不是必需的步骤。</p>\n\n<p>如果运行成功，你会在屏幕上读到下面的输出。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container run hello-world\n\nHello from Docker!\nThis message shows that your installation appears to be working correctly.\n\n... ...\n</code></pre>\n</blockquote>\n\n<p>输出这段提示以后，<code>hello world</code>就会停止运行，容器自动终止。</p>\n\n<p>有些容器不会自动终止，因为提供的是服务。比如，安装运行 Ubuntu 的 image，就可以在命令行体验 Ubuntu 系统。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container run -it ubuntu bash\n</code></pre>\n</blockquote>\n\n<p>对于那些不会自动终止的容器，必须使用<code>docker container kill</code>&nbsp;命令手动终止。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container kill [containID]\n</code></pre>\n</blockquote>\n\n<h2>八、容器文件</h2>\n\n<p><strong>image 文件生成的容器实例，本身也是一个文件，称为容器文件。</strong>也就是说，一旦容器生成，就会同时存在两个文件： image 文件和容器文件。而且关闭容器并不会删除容器文件，只是容器停止运行而已。</p>\n\n<blockquote>\n<pre>\n<code>\n# 列出本机正在运行的容器\n$ docker container ls\n\n# 列出本机所有容器，包括终止运行的容器\n$ docker container ls --all\n</code></pre>\n</blockquote>\n\n<p>上面命令的输出结果之中，包括容器的 ID。很多地方都需要提供这个 ID，比如上一节终止容器运行的<code>docker container kill</code>命令。</p>\n\n<p>终止运行的容器文件，依然会占据硬盘空间，可以使用<code>docker container rm</code>命令删除。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container rm [containerID]\n</code></pre>\n</blockquote>\n\n<p>运行上面的命令之后，再使用<code>docker container ls --all</code>命令，就会发现被删除的容器文件已经消失了。</p>\n\n<h2>九、Dockerfile 文件</h2>\n\n<p>学会使用 image 文件以后，接下来的问题就是，如何可以生成 image 文件？如果你要推广自己的软件，势必要自己制作 image 文件。</p>\n\n<p>这就需要用到 Dockerfile 文件。它是一个文本文件，用来配置 image。Docker 根据 该文件生成二进制的 image 文件。</p>\n\n<p>下面通过一个实例，演示如何编写 Dockerfile 文件。</p>\n\n<h2>十、实例：制作自己的 Docker 容器</h2>\n\n<p>下面我以&nbsp;koa-demos&nbsp;项目为例，介绍怎么写 Dockerfile 文件，实现让用户在 Docker 容器里面运行 Koa 框架。</p>\n\n<p>作为准备工作，请先下载源码。</p>\n\n<blockquote>\n<pre>\n<code>\n$ git clone https://github.com/ruanyf/koa-demos.git\n$ cd koa-demos\n</code></pre>\n</blockquote>\n\n<h3>10.1 编写 Dockerfile 文件</h3>\n\n<p>首先，在项目的根目录下，新建一个文本文件<code>.dockerignore</code>，写入下面的内容。</p>\n\n<blockquote>\n<pre>\n<code>\n.git\nnode_modules\nnpm-debug.log\n</code></pre>\n</blockquote>\n\n<p>上面代码表示，这三个路径要排除，不要打包进入 image 文件。如果你没有路径要排除，这个文件可以不新建。</p>\n\n<p>然后，在项目的根目录下，新建一个文本文件 Dockerfile，写入下面的内容。</p>\n\n<blockquote>\n<pre>\n<code>\nFROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\n</code></pre>\n</blockquote>\n\n<p>上面代码一共五行，含义如下。</p>\n\n<blockquote>\n<ul>\n	<li><code>FROM node:8.4</code>：该 image 文件继承官方的 node image，冒号表示标签，这里标签是<code>8.4</code>，即8.4版本的 node。</li>\n	<li><code>COPY . /app</code>：将当前目录下的所有文件（除了<code>.dockerignore</code>排除的路径），都拷贝进入 image 文件的<code>/app</code>目录。</li>\n	<li><code>WORKDIR /app</code>：指定接下来的工作路径为<code>/app</code>。</li>\n	<li><code>RUN npm install</code>：在<code>/app</code>目录下，运行<code>npm install</code>命令安装依赖。注意，安装后所有的依赖，都将打包进入 image 文件。</li>\n	<li><code>EXPOSE 3000</code>：将容器 3000 端口暴露出来， 允许外部连接这个端口。</li>\n</ul>\n</blockquote>\n\n<h3>10.2 创建 image 文件</h3>\n\n<p>有了 Dockerfile 文件以后，就可以使用<code>docker image build</code>命令创建 image 文件了。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image build -t koa-demo .\n# 或者\n$ docker image build -t koa-demo:0.0.1 .\n</code></pre>\n</blockquote>\n\n<p>上面代码中，<code>-t</code>参数用来指定 image 文件的名字，后面还可以用冒号指定标签。如果不指定，默认的标签就是<code>latest</code>。最后的那个点表示 Dockerfile 文件所在的路径，上例是当前路径，所以是一个点。</p>\n\n<p>如果运行成功，就可以看到新生成的 image 文件<code>koa-demo</code>了。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image ls\n</code></pre>\n</blockquote>\n\n<h3>10.3 生成容器</h3>\n\n<p><code>docker container run</code>命令会从 image 文件生成容器。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container run -p 8000:3000 -it koa-demo /bin/bash\n# 或者\n$ docker container run -p 8000:3000 -it koa-demo:0.0.1 /bin/bash\n</code></pre>\n</blockquote>\n\n<p>上面命令的各个参数含义如下：</p>\n\n<blockquote>\n<ul>\n	<li><code>-p</code>参数：容器的 3000 端口映射到本机的 8000 端口。</li>\n	<li><code>-it</code>参数：容器的 Shell 映射到当前的 Shell，然后你在本机窗口输入的命令，就会传入容器。</li>\n	<li><code>koa-demo:0.0.1</code>：image 文件的名字（如果有标签，还需要提供标签，默认是 latest 标签）。</li>\n	<li><code>/bin/bash</code>：容器启动以后，内部第一个执行的命令。这里是启动 Bash，保证用户可以使用 Shell。</li>\n</ul>\n</blockquote>\n\n<p>如果一切正常，运行上面的命令以后，就会返回一个命令行提示符。</p>\n\n<blockquote>\n<pre>\n<code>\nroot@66d80f4aaf1e:/app#\n</code></pre>\n</blockquote>\n\n<p>这表示你已经在容器里面了，返回的提示符就是容器内部的 Shell 提示符。执行下面的命令。</p>\n\n<blockquote>\n<pre>\n<code>\nroot@66d80f4aaf1e:/app# node demos/01.js\n</code></pre>\n</blockquote>\n\n<p>这时，Koa 框架已经运行起来了。打开本机的浏览器，访问 http://127.0.0.1:8000，网页显示&quot;Not Found&quot;，这是因为这个&nbsp;demo&nbsp;没有写路由。</p>\n\n<p>这个例子中，Node 进程运行在 Docker 容器的虚拟环境里面，进程接触到的文件系统和网络接口都是虚拟的，与本机的文件系统和网络接口是隔离的，因此需要定义容器与物理机的端口映射（map）。</p>\n\n<p>现在，在容器的命令行，按下 Ctrl + c 停止 Node 进程，然后按下 Ctrl + d （或者输入 exit）退出容器。此外，也可以用<code>docker container kill</code>终止容器运行。</p>\n\n<blockquote>\n<pre>\n<code>\n# 在本机的另一个终端窗口，查出容器的 ID\n$ docker container ls\n\n# 停止指定的容器运行\n$ docker container kill [containerID]\n</code></pre>\n</blockquote>\n\n<p>容器停止运行之后，并不会消失，用下面的命令删除容器文件。</p>\n\n<blockquote>\n<pre>\n<code>\n# 查出容器的 ID\n$ docker container ls --all\n\n# 删除指定的容器文件\n$ docker container rm [containerID]\n</code></pre>\n</blockquote>\n\n<p>也可以使用<code>docker container run</code>命令的<code>--rm</code>参数，在容器终止运行后自动删除容器文件。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container run --rm -p 8000:3000 -it koa-demo /bin/bash\n</code></pre>\n</blockquote>\n\n<h3>10.4 CMD 命令</h3>\n\n<p>上一节的例子里面，容器启动以后，需要手动输入命令<code>node demos/01.js</code>。我们可以把这个命令写在 Dockerfile 里面，这样容器启动以后，这个命令就已经执行了，不用再手动输入了。</p>\n\n<blockquote>\n<pre>\n<code>\nFROM node:8.4\nCOPY . /app\nWORKDIR /app\nRUN npm install --registry=https://registry.npm.taobao.org\nEXPOSE 3000\nCMD node demos/01.js\n</code></pre>\n</blockquote>\n\n<p>上面的 Dockerfile 里面，多了最后一行<code>CMD node demos/01.js</code>，它表示容器启动后自动执行<code>node demos/01.js</code>。</p>\n\n<p>你可能会问，<code>RUN</code>命令与<code>CMD</code>命令的区别在哪里？简单说，<code>RUN</code>命令在 image 文件的构建阶段执行，执行结果都会打包进入 image 文件；<code>CMD</code>命令则是在容器启动后执行。另外，一个 Dockerfile 可以包含多个<code>RUN</code>命令，但是只能有一个<code>CMD</code>命令。</p>\n\n<p>注意，指定了<code>CMD</code>命令以后，<code>docker container run</code>命令就不能附加命令了（比如前面的<code>/bin/bash</code>），否则它会覆盖<code>CMD</code>命令。现在，启动容器可以使用下面的命令。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container run --rm -p 8000:3000 -it koa-demo:0.0.1\n</code></pre>\n</blockquote>\n\n<h3>10.5 发布 image 文件</h3>\n\n<p>容器运行成功后，就确认了 image 文件的有效性。这时，我们就可以考虑把 image 文件分享到网上，让其他人使用。</p>\n\n<p>首先，去&nbsp;hub.docker.com&nbsp;或&nbsp;cloud.docker.com&nbsp;注册一个账户。然后，用下面的命令登录。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker login\n</code></pre>\n</blockquote>\n\n<p>接着，为本地的 image 标注用户名和版本。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image tag [imageName] [username]/[repository]:[tag]\n# 实例\n$ docker image tag koa-demos:0.0.1 ruanyf/koa-demos:0.0.1\n</code></pre>\n</blockquote>\n\n<p>也可以不标注用户名，重新构建一下 image 文件。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image build -t [username]/[repository]:[tag] .\n</code></pre>\n</blockquote>\n\n<p>最后，发布 image 文件。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker image push [username]/[repository]:[tag]\n</code></pre>\n</blockquote>\n\n<p>发布成功以后，登录 hub.docker.com，就可以看到已经发布的 image 文件。</p>\n\n<h2>十一、其他有用的命令</h2>\n\n<p>docker 的主要用法就是上面这些，此外还有几个命令，也非常有用。</p>\n\n<p><strong>（1）docker container start</strong></p>\n\n<p>前面的<code>docker container run</code>命令是新建容器，每运行一次，就会新建一个容器。同样的命令运行两次，就会生成两个一模一样的容器文件。如果希望重复使用容器，就要使用<code>docker container start</code>命令，它用来启动已经生成、已经停止运行的容器文件。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container start [containerID]\n</code></pre>\n</blockquote>\n\n<p><strong>（2）docker container stop</strong></p>\n\n<p>前面的<code>docker container kill</code>命令终止容器运行，相当于向容器里面的主进程发出 SIGKILL 信号。而<code>docker container stop</code>命令也是用来终止容器运行，相当于向容器里面的主进程发出 SIGTERM 信号，然后过一段时间再发出 SIGKILL 信号。</p>\n\n<blockquote>\n<pre>\n<code>\n$ bash container stop [containerID]\n</code></pre>\n</blockquote>\n\n<p>这两个信号的差别是，应用程序收到 SIGTERM 信号以后，可以自行进行收尾清理工作，但也可以不理会这个信号。如果收到 SIGKILL 信号，就会强行立即终止，那些正在进行中的操作会全部丢失。</p>\n\n<p><strong>（3）docker container logs</strong></p>\n\n<p><code>docker container logs</code>命令用来查看 docker 容器的输出，即容器里面 Shell 的标准输出。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令查看输出。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container logs [containerID]\n</code></pre>\n</blockquote>\n\n<p><strong>（4）docker container exec</strong></p>\n\n<p><code>docker container exec</code>命令用于进入一个正在运行的 docker 容器。如果<code>docker run</code>命令运行容器的时候，没有使用<code>-it</code>参数，就要用这个命令进入容器。一旦进入了容器，就可以在容器的 Shell 执行命令了。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container exec -it [containerID] /bin/bash\n</code></pre>\n</blockquote>\n\n<p><strong>（5）docker container cp</strong></p>\n\n<p><code>docker container cp</code>命令用于从正在运行的 Docker 容器里面，将文件拷贝到本机。下面是拷贝到当前目录的写法。</p>\n\n<blockquote>\n<pre>\n<code>\n$ docker container cp [containID]:[/path/to/file] .\n</code></pre>\n</blockquote>\n\n<p>非常感谢你一直读到了这里，这个系列还有下一篇，介绍如何使用 Docker 搭建真正的网站，欢迎继续阅读。</p>\n\n<p>（完）</p>\n\n<h3>文档信息</h3>\n\n<ul>\n	<li>版权声明：自由转载-非商用-非衍生-保持署名（创意共享3.0许可证）</li>\n	<li>发表日期：&nbsp;2018年2月 9日</li>\n	<li>更多内容：&nbsp;档案&nbsp;&raquo;&nbsp;开发者手册</li>\n	<li>文集：《前方的路》，《未来世界的幸存者》</li>\n	<li>社交媒体：&nbsp;twitter，&nbsp;weibo</li>\n</ul>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>相关文章</h2>\n\n<ul>\n	<li><strong>2018.02.13:&nbsp;Docker 微服务教程</strong>\n\n	<p>Docker 是一个容器工具，提供虚拟环境。很多人认为，它改变了我们对软件的认识。</p>\n	</li>\n	<li><strong>2017.12.19:&nbsp;持续集成服务 Travis CI 教程</strong>\n	<p>编写代码只是软件开发的一小部分，更多的时间往往花在构建（build）和测试（test）。</p>\n	</li>\n	<li><strong>2017.11.15:&nbsp;Bash 脚本 set 命令教程</strong>\n	<p>服务器的开发和管理离不开 Bash 脚本，掌握它需要学习大量的细节。</p>\n	</li>\n	<li><strong>2017.11.02:&nbsp;双因素认证（2FA）教程</strong>\n	<p>所谓认证（authentication）就是确认用户的身份，是网站登录必不可少的步骤。</p>\n	</li>\n</ul>\n\n<h2>广告（购买广告位）</h2>\n\n<p>&nbsp;</p>\n\n<p>&nbsp;</p>\n\n<h2>留言（24条）</h2>\n\n<p>辣条拌鱼翅&nbsp;说：</p>\n\n<p><br />\n写下docker的一些感觉, 做为服务端的RD, 在本地开发后要把程序放到线上, 由于各种原因本地开发的机器可能要替换等等. 那么开发环境一但改变, 就要重新为程序安装各种服务与扩展. 这些工作也许不难, 但是做为RD 不应该做重复的事. 使用docker后, 先把环境编排好后, 以后只要一条命令就可以完成环境的部署, 一劳永逸呀.</p>\n\n<p>http://www.majianwei.com/?s=docker</p>\n\n<p>2018年2月 9日 08:40&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>ehlxr&nbsp;说：</p>\n\n<p>阮老师出品，比属精品</p>\n\n<p>2018年2月 9日 09:17&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>勒布朗&nbsp;说：</p>\n\n<p>写的很好</p>\n\n<p>2018年2月 9日 10:26&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>ixx&nbsp;说：</p>\n\n<p>docker 在微服务领域优势明显 结合k8s的生态体系 对开发和运维来说真的是省了好多事&nbsp;<br />\n推荐一个小工具 方便查看log 进入容器shell 以及启动、重启、偏上容器的扩展命令<br />\nhttps://github.com/iuv/xx</p>\n\n<p>2018年2月 9日 10:37&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>阮老师牛逼&nbsp;说：</p>\n\n<p>我一直以为docker指的是tor里面经常使用的搜索引擎。 [狗头]</p>\n\n<p>2018年2月 9日 10:41&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>iStar&nbsp;说：</p>\n\n<p>太感谢了，真是我想看什么，阮老师就写什么。:)</p>\n\n<p>2018年2月 9日 10:48&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>小青岛&nbsp;说：</p>\n\n<p>你好<br />\n阮一峰<br />\n如果你有兴致的话、我希望你有时间能写一篇专门针对linux容器的文章。<br />\n谢谢：）</p>\n\n<p>2018年2月 9日 10:50&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>anne&nbsp;说：</p>\n\n<p>阮老师写的很棒，我一步步操作下来了，就是这条命令需要改一下</p>\n\n<p>$ docker container ls</p>\n\n<p>需要改成</p>\n\n<p>$ docker container ls -l</p>\n\n<p>2018年2月 9日 11:08&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>Linky&nbsp;说：</p>\n\n<p>感谢分享，老师总能把一个复杂的东西讲得直白，容易理解。</p>\n\n<p>2018年2月 9日 11:14&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>szpzs&nbsp;说：</p>\n\n<p>一直很排斥去学习docker。现在有了阮老师的入门教程，一下子就有了学它的兴趣了。谢谢阮老师。</p>\n\n<p>2018年2月 9日 11:29&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>llfylwg&nbsp;说：</p>\n\n<p>对于前端来说有啥用呢？</p>\n\n<p>2018年2月 9日 13:02&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>Simon&nbsp;说：</p>\n\n<p>感谢阮老师！</p>\n\n<p>2018年2月 9日 13:38&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>zhiyang&nbsp;说：</p>\n\n<p>博主你有很多文章的链接怎么都打不开啊，例如那个koa教程</p>\n\n<p>2018年2月 9日 15:09&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>咯叩&nbsp;说：</p>\n\n<p>作为前端需要运行复杂的后端环境的人员来说，这个简直救命了~~</p>\n\n<p>2018年2月 9日 15:31&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>timothy&nbsp;说：</p>\n\n<blockquote>\n<pre>\n引用llfylwg的发言：</pre>\n\n<p>对于前端来说有啥用呢？</p>\n</blockquote>\n\n<p>为什么要对前端有用？</p>\n\n<p>2018年2月 9日 15:33&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>jack&nbsp;说：</p>\n\n<p>感觉一般</p>\n\n<p>2018年2月 9日 16:44&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>Cwift&nbsp;说：</p>\n\n<p>等续集!!!</p>\n\n<p>2018年2月 9日 17:01&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>wangjian&nbsp;说：</p>\n\n<p>写得很好，特别是命令加上了container/image</p>\n\n<p>2018年2月10日 08:53&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>孑孓&nbsp;说：</p>\n\n<blockquote>\n<pre>\n引用timothy的发言：</pre>\n\n<p>&nbsp;</p>\n\n<p>为什么要对前端有用？</p>\n</blockquote>\n\n<p>不用那么狭隘，知识的深度和广度都是程序员极力追求的</p>\n\n<p>2018年2月10日 18:13&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>LeeMo&nbsp;说：</p>\n\n<p>等阮老师的续集...</p>\n\n<p>2018年2月11日 11:03&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>netwolf103&nbsp;说：</p>\n\n<p>简单清晰，给一个赞。</p>\n\n<p>2018年2月11日 23:11&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>徐超鹏&nbsp;说：</p>\n\n<p>精品</p>\n\n<p>2018年2月12日 09:19&nbsp;|&nbsp;#&nbsp;|&nbsp;引用</p>\n\n<p>王昊天&nbsp;说：</p>\n', '/uploads\\avatar-1518854657497.jpg', '2018', '2', '17');
